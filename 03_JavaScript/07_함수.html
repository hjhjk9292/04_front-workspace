<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!--
        * 함수 작성 방법
        1. 함수 선언식 function 함수명() {} //ㅡ 기명함수 선언
        2. 함수 표현식 const fn = function() {} //ㅡ 익명함수에 대입
        3. 화살표 함수 const arrow = () => {};    
    -->

    <h2>함수 선언식 vs 함수 표현식</h2>
    <script>
        /*
            * 함수 선언식
            1. 함수 이름을 결정해서 함수를 정의하는 방식 (== 기명함수)
            2. 함수 선언식은 호이스팅(hoisting)의 대상이 되므로, 코드 Line에 상관없이 언제든 호출 가능
            3. 예시

                named(); // 호이스팅
                function named(){ // 정의(함수를 정의했다)
                    실행내용
                }

                named(); // 호출(함수를 호출한다 == 함수를 콜한다)
            4. 단, 동일한 이름의 함수가 다시 정의될 경우 오류 안나고 마지막 함수가 적용됨.
            
        */

        fnDeclare();

        // 함수 선언(정의) => 호이스팅의 대상이 됨
        function fnDeclare(){
            console.log("함수 실행");
        }

        function fnDeclare(){
            console.log("짝꿍이 만든 함수"); // 동일한 함수가 있을 경우 마지막 함수 적용된 예시
        }

        /*
            * 함수 표현식
            1. 함수를 변수에 저장하는 방식
            2. 주로 익명함수를 변수에 저장함 (기명함수도 대입 가능하긴함)
            3. 변수를 함수처럼 호출해서 사용할 수 있음
            4. 함수 표현식은 호이스팅의 대상이 되지 않음
            5. 예시
                const expression1 = function() { // 익명함수를 대입한 것!
                    실행내용;
                }

                expression1();

                const expression2 = named; // 이미 존재하는 기명함수를 변수에 대입한 방식
        */
 
    //    fnExpression1(); // 호이스팅의 대상이 되지 않음
       const fnExpression1 = function() { // 이름을 작성x / 가명 / 익명함수를 대입한 경우
            console.log("익명함수1");
       }

       const fnExpression2 = fnDeclare;
       fnExpression2();
       
    </script>

    <hr>

    <script>
        /*
            * 인자(전달값)와 매개변수
            1. 함수 호출 시 전달되는 값을 인자[값] 라고 함
               이 때 해당 값을 받아주기 위해 매개변수를 정의해둘 수 있음
            2. 매개변수 선언 시에 선언 키워드(var, let, const) 사용하지 않음
            3. 전개 구문(Spread Syntax) 또는 arguments 배열을 이용해서
               0개 이상의 인자를 처리할 수 있음
            4. 인자가 전달되지 않는 경우에 사용할 디폴트값을 지정할 수 있음
        */

        /* 함수 선언식 방식
        function fnParamTest(param){
            console.log(param)
        }
        */

        // 함수 표현식 방식
        const fnParamTest = function(param) {
            console.log(param);
        }

        // * 전개 구문 테스트 (Spread Syntax) ㅡ 인자를 펼쳐주는 연산자(...)
        const fnSpreadTest = function(...args) { // ...args : 전개 연산자
            console.log(args); // 배열 []
            // 일반 for문 , for in문
            // for of문
            for(let arg of args){ // arg=args[0] => arg=args[1]
                console.log(arg);
            }
        }

        // * arguments 테스트
        const fnArgumentsTest = function(){
            // function 마다 하나씩 존재하는 arguments 배열 : 인자값들이 담기는 배열
            console.log(arguments);
            for(let arg of arguments){
                console.log(arg)
            }
        }

        // * default 처리 테스트
        const fnDefaultTest = function(x, y=20) { // y값이 있으면 그 값으로 쓰지만 없으면 20으로 대입
            console.log("x :", x);
            console.log("y :", y);
        }



    </script>

    <h2>인자와 매개변수</h2>
    <!-- btn{버튼$}*6 -->
    <button onclick="fnParamTest('hello')">버튼1</button>
    <button onclick="fnParamTest(10)">버튼2</button>
    <button onclick="fnParamTest([1,2,3])">버튼3</button>
    <button onclick="fnParamTest(prompt('이름 입력'))">버튼4</button>
    <button onclick="fnParamTest()">버튼5</button>
    <!-- 매개변수 개수보다 더 적은 인자 전달 시 매개변수는 초기화(값이 매겨지지 않은) 되지 않아 undifined -->
    <button onclick="fnParamTest('a','b','c')">버튼6</button>
    <!-- 매개변수 개수보다 더 많은 인자 전달 시 초과되는 값은 무시됨 ㄴa만 나오고 b,c는 무시됨-->

    <h2>전개구문</h2>
    <!-- btn{버튼$}*3 -->
    <button onclick="fnSpreadTest()">버튼1</button>
    <button onclick="fnSpreadTest(1,2)">버튼2</button>
    <button onclick="fnSpreadTest('a','b','c')">버튼3</button>

    <h2>arguments 배열</h2>
    <!-- btn{버튼$}*3 -->
    <button onclick="fnArgumentsTest()">버튼1</button>
    <button onclick="fnArgumentsTest(1,2)">버튼2</button>
    <button onclick="fnArgumentsTest('a','b','c')">버튼3</button>

    <h2>default 처리</h2>
    <!-- btn{버튼$}*3 -->
    <button onclick="fnDefaultTest(1, 2)">버튼1</button>
    <button onclick="fnDefaultTest(1)">버튼2</button> <!-- y의 값이 20으로 나옴-->
    <button onclick="fnDefaultTest()">버튼3</button> <!-- x : undefined / y:20-->

    <script>
        /*
            * 매개변수에 this 인자 전달
            1. 이벤트가 발생된 요소를 전달하고자 할 경우 this를 인자로 전달할 수 있음
            2. 해당 함수 내에서 현재 이벤트가 발생된 요소를 제어할 수 있음
        */

        const fnClickedBtn = function(el){
            console.log(el);
            el.innerHTML = "클릭됨"; // 버튼1 or 버튼2 눌렀을 때 el로 요소가 전달되고 버튼->클릭됨 으로 변경됨
        }

        const fnClickedBtnValue = function(value){
            console.log(value);
        }
    </script>

    <h2>this 관련 전달해보기</h2>
    <!-- btn{버튼$}*2 -->
    <button onclick="fnClickedBtn(this)">버튼1</button> <!-- this(지금 니가 누른 그 것) : 지금 현재 이벤트가 발생한 그 것 => 이 버튼이 el로 전달됨-->
    <button onclick="fnClickedBtn(this)">버튼2</button>

    <!-- this(현재 이벤트가 발생된 그 요소!)-->
    <input type="button" value="버튼3" onclick="fnClickedBtnValue(this.value)">
    <input type="button" value="버튼4" onclick="fnClickedBtnValue(this.value)">

    <hr>

    <script>
        /*
            * 반환(return)
            1. 반환값이 존재하더라도 반환 타입은 작성하지 않음
            2. return 값; 을 통해 값을 반환하면서 함수 종료
            3. return; 을 통해 함수 강제 종료
        */

        const fnReturnRanNum = function() { // 정수형 만들어주는 함수
            // 1부터 10까지의 정수 랜덤값 반환
            // 자바 : (int)(Math.random() * 10 + 1) // ㅡ 1에서부터 10까지의 랜덤값을 int로 형변환해서 구하는 코드
            return parseInt(Math.random() * 10 + 1);
        }
        // console.log(fnReturnRanNum()) // console에 새로고침할 때마다 랜덤하게 숫자들 나온다

        const fnOneToRanNum = function(){
            // 1부터 랜덤수까지 매번 1씩 증가되는 값 출력
            let random = fnReturnRanNum(); // 정수형 만들어주는 함수 호출
            for(let i=1; i<=random; i++){
                console.log(i)
            }
        }

        // 반환 시 함수도 반환할 수 있음
        const fnReturnFunc = function() {
            console.log("fnReturnFunc 함수가 호출됐당");
            return function() {
                console.log("fnReturnFunc 호출 시 반환되는 함수가 실행됐당")
            }
        }

        // 익명함수를 호출하고자 할 때 ㅡ 이렇게 쓰는 경우도 있는데 잘 사용하진 않음
        // (function() {
        //     console.log("이거는 익명함수!");
        // }());

    </script>

    <h2>함수의 리턴</h2>
    <button onclick="fnOneToRanNum()">버튼1</button>
    <button onclick="fnReturnFunc()()">버튼2</button> 
    <!-- ()() 소괄호 2번 쓰는 이유 → 첫번째 ()는 fnReturnFunc 호출 / 두번째()는  return function(){} / 소괄호 1번만 작성할 경우 반환되는 함수는 머물러 있기만 함→ -->

    <hr>

    <script>
        /*
            * 함수의 중첩
            1. 함수 내부에서 사용할 또 다른 함수를 선언할 수 있음
            2. 외부 함수는 내부 함수의 변수를 사용할 수 없음
               단, 내부함수는 외부함수의 변수를 사용할 수 있음
        
        */
       function fnOuter(a){ // a라는 매개변수 받아오고 싶음, 10이 담김
            console.log("fnOuter 함수 실행", a)
            fnInner(a+1); // 기명함수라서 호이스팅 대상 ㄱ

            function fnInner(b){ // a+1 이 b에 담김
                console.log("fnInner 함수 실행", a, b) // 내부함수에서는 외부함수의 변수 사용 가능
            }

            // console.log(b); // b is not defined 외부 함수에서는 내부함수 변수 사용 불가능

       }
    </script>

    <h2>함수의 중첩</h2>
    <button onclick="fnOuter(10)">버튼</button> <!-- 10을 넘김 -->

    <hr>

    <script>
        /*
            * 화살표 함수 (arrow function)
            1. 람다 함수라고도 표현
            2. 함수 표현식의 간결한 대안 (기존에 작성했던 익명함수를 화살표함수로 표현)
            3. 가독성을 높이고 간단하게 표현 가능함
            4. 단, 화살표함수에서는 arguments를 지원하지 않음
            5. 작성법
                () => { 실행내용 }

                ㄴ () : 매개변수의 작성란
                ㄴ {} : 함수내의 코드 작성란

            6. 특징
                1) 단일 매개변수일 경우 소괄호() 생략 가능
                2) 단일 실행문일 경우 중괄호{} 생략 가능 value => console.log("안녕")
                3) 별도의 실행내용 없이 결과값 반환만 존재할 경우 {}, return 생략 가능 val => return 1; 에서 val => 1;

            7. 예시
                1. () => 단일 실행문; 
                
                // 화살표 함수로 변경 전.. 생략 순서 → function(){실행문} → () => {실행문} → () => 실행문

                2. param => 단일실행문; // 매개변수 1개 실행문도 1개 // 매개변수 1개, 단일실행문이라 () 소괄호 생략 가능

                // 변경 전
                function(param){단일실행문}

                3. (param) => return 할 값; // 매개변수 1개 리턴할 값 1개

                4. (param1,param2) => {
                        실행내용
                        retrun 결과값;
                    }

                // 매개변수 2개면 소괄호 없애면 안됨
                // 변경 전
                function(param1,param2) {
                    실행내용
                    return 결과값
                }

                5. param => {
                    실행내용1; 
                    실행내용2;}

                // 변경 전
                function(param){
                    실행내용1;
                    실행내용2;
                }
                                    
                
                6. (param1, param2) => {실행내용1; 실행내용2;}

                // 변경 전
                function(param1, param2) {
                    실행내용1;
                    실행내용2;
                }
 
        */

        // 기존에 익명함수를 통한 함수 표현식
        const fnExp1 = function(){
            console.log("fnExp1");
        }

        const fnExp2 = function(a){
            console.log("fnExp2");
            console.log(a);
        }

        const fnExp3 = function(a, b){
            console.log("fnExp3");
            console.log(a, b);
            return a + b;
        }

        const fnExp4 = function(a, b){
            return a + b;
        }

        // 위의 내용들을 화살표 함수로 작성
        // fnArrow1 ~ fnArrow4
        const fnArrow1 = () => console.log("뽀삐"); // 단일 실행문은 {} 생략 가능

        const fnArrow2 = a => { // 단일 매개변수는 () 생략 가능
            console.log("fnExp2");
            console.log(a);
        }

        const fnArrow3 = (a, b) => {
            console.log("fnExp3");
            console.log(a, b);
            return a + b;
        }

        const fnArrow4 = (a, b) => a + b;
        // 별도의 실행문 없이 바로 return 결과값; 일 경우 {}, return 생략 가능

        // 단, 화살표 함수 사용시에는 arguments 사용 불가 (전개 연산자 사용하면 됨)
        const fnArrow5 = () => {
            console.log(arguments);
        }

        const fnArrow6 = (...args) => { // 전개연산자 : ... // args가 아니어도 됨, 뽀삐 등 가능
            console.log(args);
        }
        
    </script>

    <h2>화살표 함수</h2>
    <!-- btn{fnArrow$}*6 -->
    <button onclick="fnArrow1()">fnArrow1</button>
    <button onclick="fnArrow2(10)">fnArrow2</button>
    <button onclick="console.log(fnArrow3(10,20))">fnArrow3</button> <!-- console.log() 를 해줘야 return값 30까지 같이 출력됨-->
    <button onclick="console.log(fnArrow4(100,200))">fnArrow4</button>
    <button onclick="fnArrow5(1,2,3)">fnArrow5</button> <!-- arguments 잘되면 1,2,3이 배열로 담겨야하지만 화살표 함수를 사용했기 때문에 arguments is not defined 출력 X-->
    <button onclick="fnArrow6(1,2,3)">fnArrow6</button> <!-- 전개연산자로 1,2,3 인자 넘긴 것 출력 O-->

    <hr>

    <script>
        /*
            * 콜백함수
            1. 인자로 다른 함수에 전달돼서 실행되는 함수
            2. a함수를 전달받은 b함수는 본문에서 a함수를 다시 호출해야되므로 callback 이라함        
        */

        // 예시. 로그인 기능 구현 시 마다 아이디/비번/이메일/토큰 중에 
        //       매번 두 개를 체크해야 된다고 가정

        // 각 체크를 담당하는 함수들을 미리 정의
        const fnIdCheck = () => {
            console.log("아이디 체크");
        }

        const fnPwdCheck = () => {
            console.log("비밀번호 체크");
        }

        const fnEmailCheck = () => {
            console.log("이메일 체크");
        }

        const fnTOkenCheck = () => {
            console.log("토큰 체크");
        }

        // > 로그인을 처리하는 함수 정의
        // 이 때 체크해야될 두 개의 함수를 콜백함수로 전달받기
        const fnLogin = (fnCheck1, fnCheck2) => {
            fnCheck1();
            fnCheck2();
            // 각 콜백 함수가 실행 // 콜백은 나중에 실행되는 것 (한 번 불러서 뒤늦게 실행되는 것)
        }
    </script>

    <h2>콜백함수</h2>

    <!-- btn{로그인$}*3 -->

    <!-- case1. 아이디 및 비번 체크해야될 경우 -->
    <button onclick="fnLogin(fnIdCheck, fnPwdCheck)">로그인1</button> <!-- fnIdCheck, fnPwdCheck == 콜백함수 -->

    <!-- case2. 이메일 및 비번 체크해야될 경우 -->
    <button onclick="fnLogin(fnEmailCheck, fnPwdCheck)">로그인2</button>

    <!-- case3. 아이디 및 토큰 체크해야될 경우 -->
    <button onclick="fnLogin(fnIdCheck, fnTOkenCheck)">로그인3</button>

    <!--
        * 따라서 fnLogin 함수를 콜백함수 사용 방식으로 정의해둘 경우
          유동적으로 실행시키고자 하는 함수를 전달시켜서 실행시킬 수 있음
    -->

    <script>
        // 특정함수랑 해당 함수를 실행시킬 횟수를 전달받는 함수 정의
        const fnRepeat = (fnAction, count) => { // fnIdCheck,10이 담김  // console.log("아 배고프다~")}, 20 이 담김
            // fnAction : 콜백함수
            // count    : 콜백함수를 실행시킬 횟수

            for(let i=0; i<count; i++){
                fnAction();
            }
        }

        fnRepeat(fnIdCheck,10); // 이미 정의되어 있는 함수 전달 // fnRepeat(함수, 횟수);

        fnRepeat(function() {
            console.log("아 배고프다~")
        }, 20); // 익명함수

        fnRepeat(() => console.log("아 배고프다~"),20);

        // 화살표 함수 모르겠으면 익명함수로 했다가 변경해주기

        fnRepeat(() => console.log("아 졸리다~"), 20); 

    </script>



</body>
</html>